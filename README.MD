## Вопрос №1:
```python
# Пример из задачи
def isEven(value) -> bool:
	return value % 2 == 0
```
Оригинальный пример представляет из себя математический подход к решению проблемы: четность определяется остатком от деления числа на 2.
```python
# Альтернативный вариант
def isEven(value) -> bool:
	return value & 1 == 0
```
Альтернатива же использует оператор побитового И с единицей: так как только первый бит числа может хранить значение, не кратное двум, то если в нем находится единица, то итоговое число будет нечетным.
Преимущества такого подхода:
- Быстрее исполнение - побитовое И является более простой операцией в сравнении со взятием остатка от числа

Возможные недостатки:
- Ограниченность целыми числами - подход полагается на знания о положении битов в данных
## Вопрос №2
Оба класса, приведенных в `ringfifo.py`, реализовывают минимальный интерфейс, необходимый для циклического FIFO буфера (aka циклической очереди):
- Проверка на пустоту структуры (метод isEmpty)
- Добавление новых элементов (метод push)
- Просмотр (peek) и получение с удалением (pop) первого элемента очереди

Кроме данных базовых операций можно также (при необходимости) реализовать:

- Перегрузку оператора __len__ для получения информации о количестве элементов
- Перегрузку оператора __getitem__ для получения данных по индексу, начиная от первого
- Перегрузку операторов __iadd__ и __add__ для добавления элементов в очередь через механизмы языка

Основное отличие между двумя реализациями - порядок хранения и, как следствие, доступа к данным. В первой реализации элементы вставляются в начало циклического массива, а во второй - в конец. При вставке в начало индекс, указывающий на конец очереди, уменьшается, что может позволять эксплуатировать отрицательные индексы Python'а, но, в большинтсве случаев, усложняет вычисления следующего индекса. При вставке в конец массива такой проблемы не наблюдается, и итоговый код за счет этого выглядит проще.
## Вопрос №3
Представленная в sort.py функция комбинирует в себе 3 алгоритма:
- Сортировка вставками для очень малых массивов (до 32 элементов)
- Быстрая сортировка для массивов малого и среднего размера (32 - 512 элементов) 
- Поразрядная сортировка для остальных (512 элементов и более). 

Сортировка вставками является простым алгоритмом, что позволяет ему быть быстрым для малых массивов, но алгоритмическая сложность O(n^2) в среднем случае быстро деградирует, из-за чего требуется поддержка более оптимальных алгоритмов.

Быстрая сортировка является одним из самых простых и эффективных алгоритмов, построенных на сравнении элементов, что позволяет ей быстро (с малым overhead'ом) сортировать массивы среднего размера. В коде используется дополнительная оптимизация, использующая сортировку вставками для сортировки малых подмассивов (до 16 элементов). Для больших массивов быстрая сортировка становится менее эффективной ввиду алгоритмической сложности O(n * log n), которая ограничивает большинство подобных алгоритмов. 

Поразрядная же сортировка не основана на сравнениях и обладает сложностью O(n * k / d), чего достигает за счет послежовательного использования стабильной (т.е. не меняющей относительный порядок элементов при сортировке) сортировки подсчетом на возрастающих разрядах числа. В данной реализации, числа делились на разряды размеров 256 (8 бит, 1 байт). Производительность поразрядной сортировки для малых массивов изначально хуже, чем для быстрой сортировки, однако, за счет лучшей сложности, она деградирует медленнее, обгоняя быструю сортировку после некоторого порога. В данной реализации, порогом был выбран размер массива в 512 элементов на основе эмпирических замеров на использованной для написания кода машине.
